import streamlit as st
import pandas as pd
import plotly.express as px

# Set up the page configuration
st.set_page_config(
    page_title="Dynamic Hash Table Analyzer",
    layout="wide",
    initial_sidebar_state="expanded",
)

# --- Load Data (The pre-generated CSV from the C code) ---
@st.cache_data
def load_data():
    try:
        # Load the data file generated by the C simulation
        df = pd.read_csv("results_data.csv")
        
        # Melt DataFrame for Probes Plot
        df_probes = df.melt(
            id_vars=['Distribution', 'Load_Factor'],
            value_vars=[col for col in df.columns if 'Probes' in col],
            var_name='Collision_Technique',
            value_name='Metric_Value'
        ).assign(Metric_Type='Average Probes')
        
        # Melt DataFrame for Timing Plot
        df_time = df.melt(
            id_vars=['Distribution', 'Load_Factor'],
            value_vars=[col for col in df.columns if 'Time_ms' in col],
            var_name='Collision_Technique',
            value_name='Metric_Value'
        ).assign(Metric_Type='Insertion Time (ms)')
        
        # Combine the two melted DataFrames
        return pd.concat([df_probes, df_time], ignore_index=True)
        
    except FileNotFoundError:
        st.error("Data file 'results_data.csv' not found. Please run the C simulation first.")
        return pd.DataFrame()

df = load_data()

# --- Title and Description ---
st.title("üßÆ Dynamic Hash Table Analyzer")
st.markdown("Visualize how different collision resolution techniques perform under varying load factors and data distributions.")

# --- Sidebar Controls ---
st.sidebar.header("Analysis Controls")

# 1. Select Dataset
distribution = st.sidebar.selectbox(
    "Select Dataset Distribution",
    df['Distribution'].unique() if not df.empty else ["Uniform", "Skewed", "Worst_Case"],
    index=0
)

# 2. Select Collision Resolution Techniques (Filter only probing techniques for timing plot)
all_techniques_probes = ['Chaining_Probes', 'Linear_Probing_Probes', 'Quadratic_Probing_Probes', 'Double_Hashing_Probes']
all_techniques_timing = ['Linear_Time_ms', 'Quadratic_Time_ms', 'Double_Time_ms']

selected_techniques_probes = st.sidebar.multiselect(
    "Select Probing Techniques (Probes Plot)",
    options=all_techniques_probes,
    default=all_techniques_probes
)

# 3. Select Load Factor (Alpha) Range
max_alpha = st.sidebar.slider(
    "Select Max Load Factor (Œ±)",
    min_value=0.1,
    max_value=1.5,
    value=1.0,
    step=0.1,
    help="Filter the analysis up to a specific load factor. Note that Open Addressing techniques typically fail above Œ± ‚âà 1."
)

st.sidebar.markdown("""
---
**Architecture:**
- **Core:** C Language
- **Visualization:** Python (Streamlit + Plotly)
""")


# --- Main Plotting Area ---
if not df.empty and selected_techniques_probes:
    
    tab1, tab2 = st.tabs(["üìä Probe Sequence Analysis", "‚è±Ô∏è Insertion Timing Analysis"])

    # --- TAB 1: Probe Analysis ---
    with tab1:
        st.subheader(f"Average Probes vs. Load Factor ({distribution} Keys)")
        
        # Filter data for Probes Plot
        df_filtered_probes = df[
            (df['Metric_Type'] == 'Average Probes') &
            (df['Distribution'] == distribution) &
            (df['Collision_Technique'].isin(selected_techniques_probes)) &
            (df['Load_Factor'] <= max_alpha)
        ]

        if df_filtered_probes.empty:
            st.warning("No probe data found for the selected filters.")
        else:
            # Create the Plotly chart for Probes
            fig_probes = px.line(
                df_filtered_probes,
                x="Load_Factor",
                y="Metric_Value",
                color="Collision_Technique",
                line_shape="spline",
                labels={
                    "Load_Factor": "Load Factor (Œ± = N/M)",
                    "Metric_Value": "Average Probes per Operation",
                    "Collision_Technique": "Technique"
                },
                template="plotly_dark",
                color_discrete_map={
                    'Chaining_Probes': 'rgb(0, 150, 255)',  # Blue
                    'Linear_Probing_Probes': 'rgb(255, 60, 60)',  # Red
                    'Quadratic_Probing_Probes': 'rgb(255, 165, 0)', # Orange
                    'Double_Hashing_Probes': 'rgb(0, 200, 0)',  # Green
                }
            )

            fig_probes.update_layout(legend_title_text='Resolution Technique', height=600)
            fig_probes.update_traces(mode='lines')
            
            st.plotly_chart(fig_probes, use_container_width=True)
            
            # Distribution Insights
            st.markdown(f"**Current Distribution:** **{distribution}**")
            if distribution == "Worst_Case":
                 st.markdown("""
                 This uses keys designed to hash to the exact same initial index, forcing maximum **primary clustering** for Linear Probing and maximum initial collision count for all others. Notice how Linear Probing performance (red line) skyrockets compared to other distributions, especially as $\\alpha \\rightarrow 1$.
                 """)

    # --- TAB 2: Timing Analysis ---
    with tab2:
        st.subheader(f"Average Insertion Time vs. Load Factor ({distribution} Keys)")
        st.caption("Note: Timing is highly dependent on system CPU load, but the relative performance remains consistent.")

        # Filter data for Timing Plot
        df_filtered_time = df[
            (df['Metric_Type'] == 'Insertion Time (ms)') &
            (df['Distribution'] == distribution) &
            (df['Load_Factor'] <= max_alpha)
        ]

        if df_filtered_time.empty:
            st.warning("Timing data is only collected for Open Addressing techniques (Linear, Quadratic, Double Hashing).")
        else:
            # Create the Plotly chart for Timing
            fig_time = px.line(
                df_filtered_time,
                x="Load_Factor",
                y="Metric_Value",
                color="Collision_Technique",
                line_shape="spline",
                labels={
                    "Load_Factor": "Load Factor (Œ± = N/M)",
                    "Metric_Value": "Average Time per Insertion (ms)",
                    "Collision_Technique": "Technique"
                },
                template="plotly_dark",
                color_discrete_map={
                    'Linear_Time_ms': 'rgb(255, 60, 60)',  # Red
                    'Quadratic_Time_ms': 'rgb(255, 165, 0)', # Orange
                    'Double_Time_ms': 'rgb(0, 200, 0)',  # Green
                }
            )
            fig_time.update_layout(legend_title_text='Resolution Technique', height=600, yaxis_type="log") # Log scale for better visibility of small times
            fig_time.update_traces(mode='lines')
            
            st.plotly_chart(fig_time, use_container_width=True)
            
            st.markdown("""
            **Key Insight:** The timing graph visually confirms the probe analysis. Techniques requiring fewer probes (**Double Hashing**) consistently result in lower average insertion times (measured in milliseconds).
            The use of a logarithmic y-axis helps visualize the exponential difference in performance as the load factor increases.
            """)

else:
    st.warning("Please check data loading or select at least one technique.")

